using System.ComponentModel;
using System.Text;
using SvnHub.App.Configuration;
using SvnHub.App.System;
using SvnHub.Domain;
using SvnHub.Infrastructure.Storage;

namespace SvnHub.Infrastructure.System;

public sealed class AuthFilesWriter : IAuthFilesWriter
{
    private readonly ICommandRunner _runner;
    private readonly SvnHubOptions _options;

    public AuthFilesWriter(ICommandRunner runner, SvnHubOptions options)
    {
        _runner = runner;
        _options = options;
    }

    private string DataDirectory
    {
        get
        {
            return Path.GetFullPath(_options.DataDirectory);
        }
    }

    private string HtpasswdPath => Path.Combine(DataDirectory, "htpasswd");
    private string AuthzPath => Path.Combine(DataDirectory, "authz");

    public Task WriteHtpasswdAsync(IReadOnlyList<PortalUser> users, CancellationToken cancellationToken = default)
    {
        var sb = new StringBuilder();

        foreach (var user in users.Where(u => u.IsActive).OrderBy(u => u.UserName, StringComparer.Ordinal))
        {
            if (string.IsNullOrWhiteSpace(user.SvnBcryptHash))
            {
                continue;
            }

            sb.Append(user.UserName);
            sb.Append(':');
            sb.Append(user.SvnBcryptHash);
            sb.Append('\n');
        }

        AtomicFileWriter.WriteAllText(HtpasswdPath, sb.ToString());
        return Task.CompletedTask;
    }

    public Task WriteAuthzAsync(PortalState state, CancellationToken cancellationToken = default)
    {
        var sb = new StringBuilder();
        sb.AppendLine("# Generated by SvnHub. DO NOT EDIT.");
        sb.AppendLine();

        sb.AppendLine("[groups]");

        var admins = state.Users
            .Where(u => u.IsActive && u.Roles.HasFlag(PortalUserRoles.AdminRepo))
            .Select(u => u.UserName)
            .OrderBy(n => n, StringComparer.Ordinal)
            .ToArray();

        sb.Append("admins = ");
        sb.AppendLine(string.Join(", ", admins));

        if (state.Groups.Count != 0)
        {
            var activeUserNamesById = state.Users
                .Where(u => u.IsActive)
                .ToDictionary(u => u.Id, u => u.UserName);

            var directUserMembersByGroup = state.GroupMembers
                .GroupBy(m => m.GroupId)
                .ToDictionary(g => g.Key, g => g.Select(x => x.UserId).Distinct().ToArray());

            var childGroupsByGroup = state.GroupGroupMembers
                .GroupBy(m => m.GroupId)
                .ToDictionary(g => g.Key, g => g.Select(x => x.ChildGroupId).Distinct().ToArray());

            var expandedUserCache = new Dictionary<Guid, string[]>(capacity: state.Groups.Count);

            string[] ExpandUsers(Guid groupId, HashSet<Guid> stack)
            {
                if (expandedUserCache.TryGetValue(groupId, out var cached))
                {
                    return cached;
                }

                if (!stack.Add(groupId))
                {
                    // Cycle detected; ignore to keep generation stable.
                    return Array.Empty<string>();
                }

                var users = new List<string>();

                if (directUserMembersByGroup.TryGetValue(groupId, out var userIds))
                {
                    foreach (var uid in userIds)
                    {
                        if (activeUserNamesById.TryGetValue(uid, out var name) && !string.IsNullOrWhiteSpace(name))
                        {
                            users.Add(name);
                        }
                    }
                }

                if (childGroupsByGroup.TryGetValue(groupId, out var childIds))
                {
                    foreach (var child in childIds)
                    {
                        users.AddRange(ExpandUsers(child, stack));
                    }
                }

                stack.Remove(groupId);

                var result = users
                    .Where(n => !string.IsNullOrWhiteSpace(n))
                    .Distinct(StringComparer.OrdinalIgnoreCase)
                    .OrderBy(n => n, StringComparer.OrdinalIgnoreCase)
                    .ToArray();

                expandedUserCache[groupId] = result;
                return result;
            }

            foreach (var group in state.Groups.OrderBy(g => g.Name, StringComparer.Ordinal))
            {
                var members = ExpandUsers(group.Id, new HashSet<Guid>());

                sb.Append(group.Name);
                sb.Append(" = ");
                sb.AppendLine(string.Join(", ", members));
            }
        }

        sb.AppendLine();

        var userNamesById = state.Users.ToDictionary(u => u.Id, u => u);
        var groupNamesById = state.Groups.ToDictionary(g => g.Id, g => g.Name);
        var rulesByRepo = state.PermissionRules
            .GroupBy(r => r.RepositoryId)
            .ToDictionary(g => g.Key, g => g.ToArray());

        foreach (var repo in state.Repositories.Where(r => !r.IsArchived).OrderBy(r => r.Name, StringComparer.Ordinal))
        {
            var repoRules = rulesByRepo.GetValueOrDefault(repo.Id) ?? [];
            var defaultAuthenticatedAccess = repo.AuthenticatedDefaultAccess ?? state.Settings.DefaultAuthenticatedAccess;
            if (defaultAuthenticatedAccess is not (AccessLevel.None or AccessLevel.Read or AccessLevel.Write))
            {
                defaultAuthenticatedAccess = AccessLevel.Write;
            }

            var paths = repoRules
                .Select(r => r.Path)
                .Append("/")
                .Distinct(StringComparer.Ordinal)
                .OrderBy(p => p, StringComparer.Ordinal)
                .ToArray();

            foreach (var path in paths)
            {
                sb.Append('[');
                sb.Append(repo.Name);
                sb.Append(':');
                sb.Append(path);
                sb.AppendLine("]");

                // Allow-list always: do not emit "* = r". Use $authenticated defaults instead.
                var authenticatedLine = defaultAuthenticatedAccess switch
                {
                    AccessLevel.Read => "$authenticated = r",
                    AccessLevel.Write => "$authenticated = rw",
                    _ => null,
                };
                if (!string.IsNullOrWhiteSpace(authenticatedLine))
                {
                    sb.AppendLine(authenticatedLine);
                }
                sb.AppendLine("@admins = rw");

                var sectionRules = repoRules
                    .Where(r => string.Equals(r.Path, path, StringComparison.Ordinal))
                    .OrderBy(r => r.CreatedAt)
                    .ToArray();

                foreach (var rule in sectionRules)
                {
                    var key = rule.SubjectType switch
                    {
                        SubjectType.User => ResolveUserKey(rule.SubjectId, userNamesById),
                        SubjectType.Group => ResolveGroupKey(rule.SubjectId, groupNamesById),
                        _ => null,
                    };

                    if (string.IsNullOrWhiteSpace(key))
                    {
                        continue;
                    }

                    sb.Append(key);
                    sb.Append(" = ");
                    sb.AppendLine(rule.Access switch
                    {
                        AccessLevel.None => "",
                        AccessLevel.Read => "r",
                        AccessLevel.Write => "rw",
                        _ => "",
                    });
                }

                sb.AppendLine();
            }
        }

        AtomicFileWriter.WriteAllText(AuthzPath, sb.ToString());
        return Task.CompletedTask;
    }

    private static string? ResolveUserKey(Guid subjectId, IReadOnlyDictionary<Guid, PortalUser> usersById)
    {
        if (!usersById.TryGetValue(subjectId, out var user) || !user.IsActive)
        {
            return null;
        }

        return user.UserName;
    }

    private static string? ResolveGroupKey(Guid subjectId, IReadOnlyDictionary<Guid, string> groupsById)
    {
        if (!groupsById.TryGetValue(subjectId, out var groupName))
        {
            return null;
        }

        return "@" + groupName;
    }

    public async Task ReloadApacheAsync(CancellationToken cancellationToken = default)
    {
        if (string.IsNullOrWhiteSpace(_options.ApacheReloadProgram))
        {
            return;
        }

        // Windows dev mode: there is usually no Apache2/systemctl. Allow user/group/repo management
        // without failing just because the reload command isn't available.
        if (OperatingSystem.IsWindows() &&
            string.Equals(_options.ApacheReloadProgram, "systemctl", StringComparison.OrdinalIgnoreCase))
        {
            return;
        }

        var args = SplitArgs(_options.ApacheReloadArguments);
        CommandResult result;
        try
        {
            result = await _runner.RunAsync(_options.ApacheReloadProgram, args, cancellationToken);
        }
        catch (InvalidOperationException ex) when (OperatingSystem.IsWindows() &&
                                                   ex.InnerException is Win32Exception { NativeErrorCode: 2 })
        {
            return;
        }

        if (!result.IsSuccess)
        {
            throw new InvalidOperationException(
                $"Apache reload failed (exit {result.ExitCode}): {result.StandardError}".Trim());
        }
    }

    private static IReadOnlyList<string> SplitArgs(string args)
    {
        if (string.IsNullOrWhiteSpace(args))
        {
            return [];
        }

        // MVP: basic split by whitespace; if you need complex quoting, switch to a real shell-arg parser.
        return args.Split(' ', StringSplitOptions.RemoveEmptyEntries | StringSplitOptions.TrimEntries);
    }
}
